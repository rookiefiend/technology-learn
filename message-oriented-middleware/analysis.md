# TCP学习

[TOC]

## TCP滑动窗口

### 背景

IP层协议属于不可靠的协议，IP层并不保证数据是否发送到了对端，TCP通过确认机制（ACK）来保证数据传输的可靠性，在比较早的时候使用的是send--wait--send的模式，其实这种模式叫做stop-wait模式，发送数据方在发送数据之后会启动定时器，但是如果数据或者ACK丢失，那么定时器到期之后，收不到ACK就认为发送出现状况，要进行重传。这种方式被称为 positive acknowledgment with retransmission (PAR)，它将导致通信效率低下。为了提升通信效率，在保证顺序，可达的前提先，提高吞吐量，引入了滑动窗口机制。

### 原理说明

先简单介绍`PAR`的工作方式的，它的基本工作流程如下图所示。

![img](TCP学习.assets/20160905224437961)

图解：

1. A 发送 M1 到 B，并启动一个定时器，记录 M1 是否超时，然后等待 ACK
2. B 收到了该消息，向 A 返回了对于该消息的 ACK
3. A 收到了消息 M1 的 ACK，然后发送了消息 M2 给 B，并启动定时器。（发送失败）
4. A 在超时时间内，未收到消息 M2 的ACK，重新发送消息 M2
5. B 收到了 M2，并向 A 返回了 ACK
6. A 收到了 M2 的ACK，消息发送成功。

由此可以看出，该方式花费了相当多的时间在等待 ACK，并且只有前一个消息的ACK收到后，才可以发送一下个消息，对网络利用率较低。

而滑动窗口机制便是对其的优化。它在接收端与发送端，分别维持了一个窗口，该窗口大小由服务端控制。对于发送端，在该窗口期内的消息，便可以不用等待前一消息的ACK，直接发送，当窗口头的连续元素的ACK消息都已收到，便可将其移除窗口，继续发送新的元素。对于接受端，也可以一次接受多个消息，并对多个消息压缩返回ACK，当窗口头连续元素都已接受成功，便可将其移除窗口头，继续接受新的消息。并且接受端还可根据自身处理能力，控制窗口大小，以此限制发送端发送数据的速率，使接收端更为安全。如下文所示：

![实现](TCP学习.assets/169cd8c84bee5e77)

在图中，我们可看出灰色1号2号3号包已经发送完毕，并且已经收到Ack。这些包就已经是过去式。4、5、6、7号包是黄色的，表示已经发送了。但是并没有收到对方的Ack，所以也不知道接收方有没有收到。8、9、10号包是绿色的。是我们还没有发送的。这些绿色也就是我们接下来马上要发送的包。 可以看出我们的窗口正好是11格。后面的11-16还没有被读进内存。要等4号-10号包有接下来的动作后，我们的包才会继续往下发送。

#### 正常情况

![正常情况](TCP学习.assets/169cd8c84c05c552)

可以看到4号包对方已经被接收到，所以被涂成了灰色。“窗口”就往右移一格，这里只要保证“窗口”是7格的。 我们就把11号包读进了我们的缓存。进入了“待发送”的状态。8、9号包已经变成了黄色，表示已经发送出去了。接下来的操作就是一样的了，确认包后，窗口往后移继续将未发送的包读进缓存，把“待发送“状态的包变为”已发送“。

#### 丢包情况

有可能我们包发过去，对方的Ack丢了。也有可能我们的包并没有发送过去。从发送方角度看就是我们没有收到Ack。

![丢包](TCP学习.assets/169cd8c84c92d41b)

发生的情况：一直在等Ack。如果一直等不到的话，我们也会把读进缓存的待发送的包也一起发过去。但是，这个时候我们的窗口已经发满了。所以并不能把12号包读进来，而是始终在等待5号包的Ack。

#### 超时重发

如果该ACK一直未到达，将在ACK超时时间后，重新发送5号包。

![超时重发](TCP学习.assets/169cd8c84caf97fd)

这时候可以看出5号包已经接受到Ack，后面的6、7、8号包也已经发送过去已Ack。窗口便继续向后移动。

## TCP为什么是三次握手

### 基本说明

为了使通信的双方能够进行可靠地数据传输，双方都需要知道对方开始序列号。

而TCP进行三次握手，实际便是为了让通信的双方都知道该端口被对方使用并知道对方的开始序列号，以此建立逻辑上的连接。

### 三次握手的原因

有了对基本说明的了解，然后可以我们可以反向分析为什么不是两次握手或四次握手。先假设如果为两次握手，看看可能出现什么问题（假设通信双方为A，B两台设备）。

#### 两次握手

1. A 发送同步信号**SYN** + **A's Initial sequence number**
2. B 发送同步信号**SYN** + **B's Initial sequence number** + **B's ACK sequence number**

##### 分析丢包的情况

- A --> B 丢失

  此时，B不会向A发送ACK，所以A可以通过超时机制，判断数据是否成功发送到B，若不成功，则重试，直到成功。

  故B必定可以直到A的初始序列号。

- B --> A 丢失

  此时，由于A不会向B发送ACK，故B不知道A是否知道了B的初始序列号，也不能通过超时重传机制重发。

  故A可能不知道B的初始序列号，不能建立可靠连接

##### 结论

仅通过两次握手，无法确保A，B两端都能知道对方的开始序列号。

#### 四次握手

1. A发送同步信号**SYN** + **A's Initial sequence number**
2. B收到A的同步信号，将A的**Initial sequence number**记录到本地，并返回ACK
3. B发送同步信号**SYN** + **B's Initial sequence number**
4. A收到B的同步信号，将B的**Initial sequence number**记录到本地，并返回ACK

##### 分析丢包情况

根据对于两次握手时的分析，我们可以知道，A与B都必定能知道对方的开始序列号。

##### 优化分析

分析握手过程，可以发现，第2步与第3步显然可以合并，在收到A的序列号时，可以以B的同步信号作为ACK发送即可。

#### 结论

根据分析可知，三次握手是最少的，可以确保通信两端都能获取对方初始序列号，并建立连接状态的次数。故TCP协议最终选择了三次握手。

## 可靠队列分析

通过对TCP三次握手，以及发送的流程的学习。要想在消息中间件中，保证消息的送达，且提升网络的利用率，则应当发送者与消费者应当满足如下要求：

- 消费者可多次消费同一消息且与消费一次结果相同
- 消费者与中间件之间，必须要有ACK机制
- 若想提升网络的利用率，则应当加入缓存机制，但此时，不能确保缓存了的消息是否真实消费，若需确保，则应当让业务发送ACK，既当业务消费完一个消息，或正式开始处理一个消息时，发送ACK到中间件，使其确保消息已被消费。